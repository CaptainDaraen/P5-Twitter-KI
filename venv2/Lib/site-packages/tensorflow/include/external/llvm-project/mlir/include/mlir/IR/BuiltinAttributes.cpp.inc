/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* AttrDef Definitions                                                        *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_ATTRDEF_LIST
#undef GET_ATTRDEF_LIST

::mlir::AffineMapAttr,
::mlir::ArrayAttr,
::mlir::DictionaryAttr,
::mlir::IntegerSetAttr,
::mlir::OpaqueAttr,
::mlir::StringAttr,
::mlir::SymbolRefAttr,
::mlir::TypeAttr,
::mlir::UnitAttr

#endif  // GET_ATTRDEF_LIST

#ifdef GET_ATTRDEF_CLASSES
#undef GET_ATTRDEF_CLASSES

namespace mlir {

namespace detail {
  struct AffineMapAttrStorage : public ::mlir::AttributeStorage {
    AffineMapAttrStorage (AffineMap value)
      : ::mlir::AttributeStorage(IndexType::get(value.getContext())), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<AffineMap>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static AffineMapAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);

      return new (allocator.allocate<AffineMapAttrStorage>())
          AffineMapAttrStorage(value);
    }
      AffineMap value;
  };
} // namespace detail
AffineMapAttr AffineMapAttr::get(AffineMap value) {
  
      return Base::get(value.getContext(), value);
    ;
}
AffineMap AffineMapAttr::getValue() const { return getImpl()->value; }
} // namespace mlir
namespace mlir {

namespace detail {
  struct ArrayAttrStorage : public ::mlir::AttributeStorage {
    ArrayAttrStorage (::llvm::ArrayRef<Attribute> value)
      : ::mlir::AttributeStorage(), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<::llvm::ArrayRef<Attribute>>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static ArrayAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);
      value = allocator.copyInto(value);

      return new (allocator.allocate<ArrayAttrStorage>())
          ArrayAttrStorage(value);
    }
      ::llvm::ArrayRef<Attribute> value;
  };
} // namespace detail
ArrayAttr ArrayAttr::get(::mlir::MLIRContext *context, ::llvm::ArrayRef<Attribute> value) {
  return Base::get(context, value);
}
::llvm::ArrayRef<Attribute> ArrayAttr::getValue() const { return getImpl()->value; }
} // namespace mlir
namespace mlir {

namespace detail {
  struct DictionaryAttrStorage : public ::mlir::AttributeStorage {
    DictionaryAttrStorage (::llvm::ArrayRef<NamedAttribute> value)
      : ::mlir::AttributeStorage(), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<::llvm::ArrayRef<NamedAttribute>>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static DictionaryAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);
      value = allocator.copyInto(value);

      return new (allocator.allocate<DictionaryAttrStorage>())
          DictionaryAttrStorage(value);
    }
      ::llvm::ArrayRef<NamedAttribute> value;
  };
} // namespace detail
::llvm::ArrayRef<NamedAttribute> DictionaryAttr::getValue() const { return getImpl()->value; }
} // namespace mlir
namespace mlir {

namespace detail {
  struct IntegerSetAttrStorage : public ::mlir::AttributeStorage {
    IntegerSetAttrStorage (IntegerSet value)
      : ::mlir::AttributeStorage(), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<IntegerSet>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static IntegerSetAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);

      return new (allocator.allocate<IntegerSetAttrStorage>())
          IntegerSetAttrStorage(value);
    }
      IntegerSet value;
  };
} // namespace detail
IntegerSetAttr IntegerSetAttr::get(IntegerSet value) {
  
      return Base::get(value.getContext(), value);
    ;
}
IntegerSet IntegerSetAttr::getValue() const { return getImpl()->value; }
} // namespace mlir
namespace mlir {

namespace detail {
  struct OpaqueAttrStorage : public ::mlir::AttributeStorage {
    OpaqueAttrStorage (Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type)
      : ::mlir::AttributeStorage(type), dialectNamespace(dialectNamespace), attrData(attrData) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<Identifier, ::llvm::StringRef, ::mlir::Type>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(dialectNamespace, attrData, getType());
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key), std::get<1>(key), std::get<2>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static OpaqueAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto dialectNamespace = std::get<0>(key);
      auto attrData = std::get<1>(key);
      auto type = std::get<2>(key);
      attrData = allocator.copyInto(attrData);

      return new (allocator.allocate<OpaqueAttrStorage>())
          OpaqueAttrStorage(dialectNamespace, attrData, type);
    }
      Identifier dialectNamespace;
      ::llvm::StringRef attrData;
  };
} // namespace detail
OpaqueAttr OpaqueAttr::get(::mlir::MLIRContext *context, Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type) {
  return Base::get(context, dialectNamespace, attrData, type);
}
OpaqueAttr OpaqueAttr::getChecked(llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::mlir::MLIRContext *context, Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type) {
  return Base::getChecked(emitError, context, dialectNamespace, attrData, type);
}
OpaqueAttr OpaqueAttr::get(Identifier dialect, StringRef attrData, Type type) {
  
      return Base::get(dialect.getContext(), dialect, attrData, type);
    ;
}
OpaqueAttr OpaqueAttr::getChecked(llvm::function_ref<::mlir::InFlightDiagnostic()> emitErrorFn, Identifier dialect, StringRef attrData, Type type) {
  
      return Base::getChecked(emitErrorFn, dialect.getContext(), dialect, attrData, type);
    ;
}
Identifier OpaqueAttr::getDialectNamespace() const { return getImpl()->dialectNamespace; }
::llvm::StringRef OpaqueAttr::getAttrData() const { return getImpl()->attrData; }
::mlir::Type OpaqueAttr::getType() const { return getImpl()->getType(); }
} // namespace mlir
namespace mlir {

namespace detail {
  struct StringAttrStorage : public ::mlir::AttributeStorage {
    StringAttrStorage (::llvm::StringRef value, ::mlir::Type type)
      : ::mlir::AttributeStorage(type), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<::llvm::StringRef, ::mlir::Type>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value, getType());
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key), std::get<1>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static StringAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);
      auto type = std::get<1>(key);
      value = allocator.copyInto(value);

      return new (allocator.allocate<StringAttrStorage>())
          StringAttrStorage(value, type);
    }
      ::llvm::StringRef value;
  };
} // namespace detail
StringAttr StringAttr::get(StringRef bytes, Type type) {
  
      return Base::get(type.getContext(), bytes, type);
    ;
}
StringAttr StringAttr::get(::mlir::MLIRContext *context, StringRef bytes) {
  
      return Base::get(context, bytes, NoneType::get(context));
    ;
}
::llvm::StringRef StringAttr::getValue() const { return getImpl()->value; }
::mlir::Type StringAttr::getType() const { return getImpl()->getType(); }
} // namespace mlir
namespace mlir {

namespace detail {
  struct SymbolRefAttrStorage : public ::mlir::AttributeStorage {
    SymbolRefAttrStorage (::llvm::StringRef rootReference, ::llvm::ArrayRef<FlatSymbolRefAttr> nestedReferences)
      : ::mlir::AttributeStorage(), rootReference(rootReference), nestedReferences(nestedReferences) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<::llvm::StringRef, ::llvm::ArrayRef<FlatSymbolRefAttr>>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(rootReference, nestedReferences);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key), std::get<1>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static SymbolRefAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto rootReference = std::get<0>(key);
      auto nestedReferences = std::get<1>(key);
      rootReference = allocator.copyInto(rootReference);
      nestedReferences = allocator.copyInto(nestedReferences);

      return new (allocator.allocate<SymbolRefAttrStorage>())
          SymbolRefAttrStorage(rootReference, nestedReferences);
    }
      ::llvm::StringRef rootReference;
      ::llvm::ArrayRef<FlatSymbolRefAttr> nestedReferences;
  };
} // namespace detail
SymbolRefAttr SymbolRefAttr::get(::mlir::MLIRContext *context, ::llvm::StringRef rootReference, ::llvm::ArrayRef<FlatSymbolRefAttr> nestedReferences) {
  return Base::get(context, rootReference, nestedReferences);
}
::llvm::StringRef SymbolRefAttr::getRootReference() const { return getImpl()->rootReference; }
::llvm::ArrayRef<FlatSymbolRefAttr> SymbolRefAttr::getNestedReferences() const { return getImpl()->nestedReferences; }
} // namespace mlir
namespace mlir {

namespace detail {
  struct TypeAttrStorage : public ::mlir::AttributeStorage {
    TypeAttrStorage (Type value)
      : ::mlir::AttributeStorage(), value(value) { }

    /// The hash key is a tuple of the parameter types.
    using KeyTy = std::tuple<Type>;

    /// Define the comparison function for the key type.
    bool operator==(const KeyTy &key) const {
      return key == KeyTy(value);
    }
  static ::llvm::hash_code hashKey(const KeyTy &key) {
      return ::llvm::hash_combine(std::get<0>(key));
    }

    /// Define a construction method for creating a new instance of this
    /// storage.
    static TypeAttrStorage *construct(::mlir::AttributeStorageAllocator &allocator,
                          const KeyTy &key) {
      auto value = std::get<0>(key);

      return new (allocator.allocate<TypeAttrStorage>())
          TypeAttrStorage(value);
    }
      Type value;
  };
} // namespace detail
TypeAttr TypeAttr::get(Type type) {
  
      return Base::get(type.getContext(), type);
    ;
}
Type TypeAttr::getValue() const { return getImpl()->value; }
} // namespace mlir
namespace mlir {
} // namespace mlir

#endif  // GET_ATTRDEF_CLASSES

