/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* AttrDef Declarations                                                       *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_ATTRDEF_CLASSES
#undef GET_ATTRDEF_CLASSES


namespace mlir {
class DialectAsmParser;
class DialectAsmPrinter;
} // namespace mlir
namespace mlir {
  class AffineMapAttr;
  class ArrayAttr;
  class DictionaryAttr;
  class IntegerSetAttr;
  class OpaqueAttr;
  class StringAttr;
  class SymbolRefAttr;
  class TypeAttr;
  class UnitAttr;

  namespace detail {
    struct AffineMapAttrStorage;
  } // end namespace detail
  class AffineMapAttr : public ::mlir::Attribute::AttrBase<AffineMapAttr, ::mlir::Attribute,
                                         detail::AffineMapAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

using ValueType = AffineMap;
    static AffineMapAttr get(AffineMap value);
    AffineMap getValue() const;
  };

  namespace detail {
    struct ArrayAttrStorage;
  } // end namespace detail
  class ArrayAttr : public ::mlir::Attribute::AttrBase<ArrayAttr, ::mlir::Attribute,
                                         detail::ArrayAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;


    using ValueType = ArrayRef<Attribute>;

    /// Return the element at the given index.
    Attribute operator[](unsigned idx) const {
      assert(idx < size() && "index out of bounds");
      return getValue()[idx];
    }

    /// Support range iteration.
    using iterator = llvm::ArrayRef<Attribute>::iterator;
    iterator begin() const { return getValue().begin(); }
    iterator end() const { return getValue().end(); }
    size_t size() const { return getValue().size(); }
    bool empty() const { return size() == 0; }

  private:
    /// Class for underlying value iterator support.
    template <typename AttrTy>
    class attr_value_iterator final
        : public llvm::mapped_iterator<ArrayAttr::iterator,
                                       AttrTy (*)(Attribute)> {
    public:
      explicit attr_value_iterator(ArrayAttr::iterator it)
          : llvm::mapped_iterator<ArrayAttr::iterator, AttrTy (*)(Attribute)>(
                it, [](Attribute attr) { return attr.cast<AttrTy>(); }) {}
      AttrTy operator*() const { return (*this->I).template cast<AttrTy>(); }
    };

  public:
    template <typename AttrTy>
    iterator_range<attr_value_iterator<AttrTy>> getAsRange() {
      return llvm::make_range(attr_value_iterator<AttrTy>(begin()),
                              attr_value_iterator<AttrTy>(end()));
    }
    template <typename AttrTy,
              typename UnderlyingTy = typename AttrTy::ValueType>
    auto getAsValueRange() {
      return llvm::map_range(getAsRange<AttrTy>(), [](AttrTy attr) {
        return static_cast<UnderlyingTy>(attr.getValue());
      });
    }
  
    static ArrayAttr get(::mlir::MLIRContext *context, ::llvm::ArrayRef<Attribute> value);
    ::llvm::ArrayRef<Attribute> getValue() const;
  };

  namespace detail {
    struct DictionaryAttrStorage;
  } // end namespace detail
  class DictionaryAttr : public ::mlir::Attribute::AttrBase<DictionaryAttr, ::mlir::Attribute,
                                         detail::DictionaryAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;


    using ValueType = ArrayRef<NamedAttribute>;

    /// Construct a dictionary with an array of values that is known to already
    /// be sorted by name and uniqued.
    static DictionaryAttr getWithSorted(MLIRContext *context,
                                        ArrayRef<NamedAttribute> value);

    /// Return the specified attribute if present, null otherwise.
    Attribute get(StringRef name) const;
    Attribute get(Identifier name) const;

    /// Return the specified named attribute if present, None otherwise.
    Optional<NamedAttribute> getNamed(StringRef name) const;
    Optional<NamedAttribute> getNamed(Identifier name) const;

    /// Support range iteration.
    using iterator = llvm::ArrayRef<NamedAttribute>::iterator;
    iterator begin() const;
    iterator end() const;
    bool empty() const { return size() == 0; }
    size_t size() const;

    /// Sorts the NamedAttributes in the array ordered by name as expected by
    /// getWithSorted and returns whether the values were sorted.
    /// Requires: uniquely named attributes.
    static bool sort(ArrayRef<NamedAttribute> values,
                     SmallVectorImpl<NamedAttribute> &storage);

    /// Sorts the NamedAttributes in the array ordered by name as expected by
    /// getWithSorted in place on an array and returns whether the values needed
    /// to be sorted.
    /// Requires: uniquely named attributes.
    static bool sortInPlace(SmallVectorImpl<NamedAttribute> &array);

    /// Returns an entry with a duplicate name in `array`, if it exists, else
    /// returns llvm::None. If `isSorted` is true, the array is assumed to be
    /// sorted else it will be sorted in place before finding the duplicate entry.
    static Optional<NamedAttribute>
    findDuplicate(SmallVectorImpl<NamedAttribute> &array, bool isSorted);

    /// Return the specified attribute if present and is an instance of
    /// `AttrClass`, null otherwise.
    template<typename AttrClass>
    AttrClass getAs(StringRef name) {
      return get(name).dyn_cast_or_null<AttrClass>();
    }

  private:
    /// Return empty dictionary.
    static DictionaryAttr getEmpty(MLIRContext *context);

    /// Return empty dictionary. This is a special variant of the above method
    /// that is used by the MLIRContext to cache the empty dictionary instance.
    static DictionaryAttr getEmptyUnchecked(MLIRContext *context);

    /// Allow access to `getEmptyUnchecked`.
    friend MLIRContext;

  public:
  
    static DictionaryAttr get(::mlir::MLIRContext *context, ArrayRef<NamedAttribute> value);
    ::llvm::ArrayRef<NamedAttribute> getValue() const;
  };

  namespace detail {
    struct IntegerSetAttrStorage;
  } // end namespace detail
  class IntegerSetAttr : public ::mlir::Attribute::AttrBase<IntegerSetAttr, ::mlir::Attribute,
                                         detail::IntegerSetAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

using ValueType = IntegerSet;
    static IntegerSetAttr get(IntegerSet value);
    IntegerSet getValue() const;
  };

  namespace detail {
    struct OpaqueAttrStorage;
  } // end namespace detail
  class OpaqueAttr : public ::mlir::Attribute::AttrBase<OpaqueAttr, ::mlir::Attribute,
                                         detail::OpaqueAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

    static OpaqueAttr get(::mlir::MLIRContext *context, Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type);
    static OpaqueAttr getChecked(llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, ::mlir::MLIRContext *context, Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type);
    static OpaqueAttr get(Identifier dialect, StringRef attrData, Type type);
    static OpaqueAttr getChecked(llvm::function_ref<mlir::InFlightDiagnostic()> emitError, Identifier dialect, StringRef attrData, Type type);

    using Base::getChecked;
    static ::mlir::LogicalResult verify(::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError, Identifier dialectNamespace, ::llvm::StringRef attrData, ::mlir::Type type);
    Identifier getDialectNamespace() const;
    ::llvm::StringRef getAttrData() const;
    ::mlir::Type getType() const;
  };

  namespace detail {
    struct StringAttrStorage;
  } // end namespace detail
  class StringAttr : public ::mlir::Attribute::AttrBase<StringAttr, ::mlir::Attribute,
                                         detail::StringAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

using ValueType = StringRef;
    static StringAttr get(StringRef bytes, Type type);
    static StringAttr get(::mlir::MLIRContext *context, StringRef bytes);
    ::llvm::StringRef getValue() const;
    ::mlir::Type getType() const;
  };

  namespace detail {
    struct SymbolRefAttrStorage;
  } // end namespace detail
  class SymbolRefAttr : public ::mlir::Attribute::AttrBase<SymbolRefAttr, ::mlir::Attribute,
                                         detail::SymbolRefAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;


    static FlatSymbolRefAttr get(MLIRContext *ctx, StringRef value);

    /// Returns the name of the fully resolved symbol, i.e. the leaf of the
    /// reference path.
    StringRef getLeafReference() const;
  
    static SymbolRefAttr get(::mlir::MLIRContext *context, ::llvm::StringRef rootReference, ::llvm::ArrayRef<FlatSymbolRefAttr> nestedReferences);
    ::llvm::StringRef getRootReference() const;
    ::llvm::ArrayRef<FlatSymbolRefAttr> getNestedReferences() const;
  };

  namespace detail {
    struct TypeAttrStorage;
  } // end namespace detail
  class TypeAttr : public ::mlir::Attribute::AttrBase<TypeAttr, ::mlir::Attribute,
                                         detail::TypeAttrStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

using ValueType = Type;
    static TypeAttr get(Type type);
    Type getValue() const;
  };

  class UnitAttr : public ::mlir::Attribute::AttrBase<UnitAttr, ::mlir::Attribute, ::mlir::AttributeStorage> {
  public:
    /// Inherit some necessary constructors from 'AttrBase'.
    using Base::Base;

    static UnitAttr get(MLIRContext *context);
  
  };
} // namespace mlir

#endif  // GET_ATTRDEF_CLASSES

